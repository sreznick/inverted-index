


## Тема: реализация приложения текстового поиска

Реализуем текстовый поиск по файлам.

Нет, не find + grep.

Реализуем схему инвертированного индекса.

Точнее, реализуем значительную ее часть, а продолжим в следующей домашке.

## Общие моменты

### Самостоятельное изучение библиотек

На свете существует масса библиотек для Python - как встроенных, так и сторонних.

Изучать их все на лекциях и семинарах невозможно.

Но в реальной жизни реальные приложения должны на них опираться.

Поэтому на занятиях мы изучаем те из них, которые основываются на каких-то неочевидных идеях,
а все остальное остается на самостоятельное изучение.

### Сторонние библиотеки

Сторонние библиотеки - те, которые не доступны из Python сразу после его установки.

Часть нашего курса и состоит в изучении таких библиотек. И было бы странно их не использовать.

Если же вам хочется использовать какую-то особо любимую стороннюю библиотеку и это не Numpy, Pandas и т.п.,
то это надо согласовать.


### Изобретение велосипедов

Иногда задания намеренно нацелены на изобретение велосипеда. Вряд ли мы мимоходом создадим систему поиска текста в файлах
лучше уже существующих, но мы это делаем, чтобы научиться создавать приложения.
И использовать готовую поисковую библиотеку было бы странно.

С другой стороны -  наша задача разбивается на подзадачи. И если в ходе такого разбиения нужно выполнить подзадачу, далекую от исходной
задачи, то уже можно и нужно поискать в стандартной библиотеке (и в одной из изучаемых нами в курсе сторонних) что-то
готовое.

Если в домашке про текстовый поиск надо удалить каталог с подкаталогами - не надо руками выписывать рекурсию. Лучше
найти подходящую функцию в стандартной библиотеке.



### Инкрементальные задания

Некоторые задания являются шагом к реализации последующих. Если вы делаете следующие задания,
то не обязательно фиксировать где-то неполные версии из текущих заданий - если только явным не сказано так
сделать.


## Задание 1

5 баллов

Создайте каркас приложения. Назовите его `search-engine.py`

Создайте функцию `main`, вход в нее.

Реализуйте обработку параметров командной строки. 

На этом этапе достаточно обрабатывать один строковый параметр и сохранять его в атрибуте `command`.

Скрипт должен при запуске

```
python3 search-engine.py init
``` 

напечатать `command: init`

На данном этапе любая команда должна восприниматься как легальная.

При запуске

```
python3 search-engine.py
```

напечатать сообщение об ошибке.

При запуске

```
python3 search-engine.py --help
```

напечатать типовую инструкцию.

Здесь вам весьма пригодится встроенная библиотека `argparse`.

https://docs.python.org/3/library/argparse.html

https://docs.python.org/3/howto/argparse.html


## Задание 2

10 баллов

Наше приложение должно выполнять несколько видов действий, для каждого из которых
может потребоваться свой набор аргументов командной строки.

Примером такого рода приложения является `git`. При его запуске из командной строки
указывается сначала подкоманда, а потом - ее параметры (`git checkout -b my-branch`).

Поэтому такого типа приложения часто называют `git style`.

В этом задании надо заложить основы такого приложения.

Пусть оно принимает следующие команды: `init`, `info`, `add` и `find`.

Остальные должны восприниматься как ошибочные. 

Для каждой подкоманды надо поддержать параметр `--root <имя корневого каталога>`.

Так же надо поддержать для каждой подкоманды свой набор параметров.

Для `init`: `--drop-existing` (`python search-engine.py init --drop-existing`)

Для `info`: ничего специфичного

Для `add`: `<имя файла>` (обязательная, т.е. `python search-engine.py add f.txt` - 
можно и нужно, а `python search-engine.py add` - нельзя)

Для `find`: `<слово 1> ... <слово n> --limit 10` (слов может быть несколько но обязано быть хотя бы одно,
а `--limit` не обязателен)

Параметр `--root` обязан быть. Он может быть до подкоманды, а может - после. Но не два раза.
Если он идет и до, и после - это ошибка.

На этом этапе достаточно:

- обработать как ошибку непредусмотренные параметры
- обработать как ошибку на отсутствующие обязательные параметры
- обработать как ошибку нечисловое значение в параметре `--limit`

В случае корректных параметров пока ничего существенного делать не надо. Достаточно напечатать
полученную подкоманду и переданные параметры в обработанном виде.

Например, при вызове `python3 search-engine.py find abc hello --limit 5` напечатайте

```
command: find
word 1: abc
word 2: hello
limit: 5
```

А при вызове `python3 search-engine.py find abc hello` напечатайте

```
command: find
word 1: abc
word 2: hello
limit: 100 (by default)
```

Старайтесь максимально задействовать возможности `argparse`.

В частности, "обработать как ошибку" означает, что лучше всего сделать так, чтобы `argparse`
вывел типовое сообщение об ошибке.

Особенно может помочь вот эта глава: https://docs.python.org/3/library/argparse.html#sub-commands 


## Задание 3

15 баллов

Реализуем подкоманду `init`.

Как следует из названия она должна проинициализировать нашу поисковую систему.

Мы хотим отвести каталог на диске под служебную информацию, которая поможет нам выполнять поиск.

Путь к этому каталогу мы и передаем в параметре `--root`.

Нужно предусмотреть следующие варианты:

- по этому пути уже есть каталог или файл

- там ничего нет, но и нам создать ничего не удается

Если нам создать ничего не удается - надо это понять и сообщить о проблеме.

Если по указанному пути живет файл - надо это понять и сообщить о проблеме.

Если по указанному пути живет - надо это понять, а дальше есть два варианта.

Если это просто какой-то каталог - не будем ничего создавать и сообщим о проблеме.

А если это корневой каталог нашей поисковой системы (ранее нами созданный) - обратимся к опции 
`--drop-existing`.

Если ее нет - не будем ничего создавать и сообщим о проблеме.

А если есть - тогда удалим.

А как мы поймем - "наш" это каталог или чей-то ?

Давайте определять по наличию файла `.se` и наличию в нем текста `IT'S SEARCH ENGINE`.
Ровно такого.

И если мы по этому маркеру решили, что это наш каталог и есть опция `--drop-existin`, то уничтожим старые данные.

Если каталога не было, то мы его создаем и заполняем:

- создаем файл-маркер `.se`
- создаем каталог `index`
- создаем каталог `files`

Содержимое файла `.se` мы знаем.

Каталог `index` оставим пустым. В каталоге `files` создадим файл `.splits` с содержимым

```
0 0
```

Также создадим в каталоге `files` пустой файл `0_files`.

Если каталог был, не пересоздаем то, что уже есть и пригодится дальше (подкаталоги, например), но приводим его в начальное состояние:

- файл-маркер `.se` оставляем как есть
- если каталог `index` существует и пуст, оставляем как есть
- если каталог `index` существует и не пуст - удаляем (возможные подкаталоги - тоже, и их подкаталоги и так далее рекурсивно)
- если каталог `index` не существует - создаем
- аналогично с каталогом `files`

Каталог `index` оставим пустым. В каталоге `files` создадим файл `.splits` с уже известным содержимым. Если он там был - перетрем. 
Аналогично с файлом `0_files`.


# Задание 4 

15 баллов

Начнем реализовывать подкоманду `add`.

Она должна добавить файл в нашу систему.

Мы исходим из того, что файлы не меняются. Поэтому снимается проблема реагирования на изменения.

И удалять файлы из нашей системы мы тоже не собираемся.

Будем только добавлять. Но следить за тем, чтобы файл не добавлялся дважды.

Сначала нам надо проверить, что файл существует. Эту проверку не надо встраивать в `argparse`.
Эту уже такая глубоко семантическая проверка.

Надо понимать, что файл в командной строке может задаваться и относительным путем, и абсолютным.
Если он задан в относительном пути - надо получить абсолютный (исходя из текущего каталога).

После получения абсолютного пути надо его привести в каноническую форму. Например, путь `/a/b/c/../d`
является абсолютным, но не каноническим. Его каноническим эквивалентом является `/a/b/d`.
(Помним про велосипеды и про то, это далековато от текстового поиска - но это важно для хорошего кода).

Получив канонический абсолютный путь к файлу, надо поискать его в files/0_files.
Как именно - станет понятно чуть ниже, после описания добавления.

Если файл нашли - сообщаем о том, что он уже добавлен.

Если не добавлен - нам нужно назначить файлу идентификатор.

Идентификатор получим следующим образом: прочитаем все строчки файлв files/.splits, суммируем все вторые колонки и прибавим к сумме 1.

Получив идентификатор, надо добавить в `files/0_files` строку вида

```
2135 /a/b/d
```

После чего надо обновить файл `files/.splits`.

В общем случае мы хотели бы работать с несколькими файлами `0_files`, `1_files` и т.д. и для каждого файла держать в файле
`files/.splits` строчку, отражающую число строк в соответствующем файле.

Полностью эту часть мы развернем в следующей домашке. А пока хотелось бы реализовать функцию, которая бы умела обновлять в файле строчку
с произвольным номером.

Функция должна принимать имя файла и номер строки. Она должна создать временный файл и перекинуть в него содержимое исходного. Строки с номером,
не равным заданному, перекидываются без изменений, а указанная - с увеличением второй колонки на 1.

После успешного переноса данных в новый файл оба файла надо закрыть и временный файл переименовать в `files/.splits`.

И дальше эту функцию нужно вызвать с параметром 0.

Таким образом мы зарегистрировали файл.

Но его содержимое пока остается для нашего индекса неизвестным.



# Задание 5 

15 баллов

Теперь надо добавить содержимое.

Содержимое будем хранить в каталоге `index`. Там будут жить файлы с именами `00`, `01`, `02` и так далее.
`00` соответствует букве `a`, `01` - `b`, `25` - `z`, `26` - `а`, `27` - `б`.

Файлы должны создаваться по мере появления слов, начинающихся с соответствующей буквы. 

Будем считать, что в файлах хранятся очень гладкие и причесанные тексты - слова, разделенные
пробелами. 

Надо подробить текст на слова, перевести в строчные, и для каждого слова, найденного в тексте, добавить в файл, соответствующий
первой букве слова, в строчку, начинающуюся с данного слова, идентификатор файла.

Формат строки такой:
```
apple: 123,233,432
```

Если слово не встречалось, его в файле нет.

При первом появлении слово надо добавить в файл.

Изменение файла делаем через создание нового с последующим переименованием.

Если в тексте несколько слов на одну букву - надо обновить файл за один раз.

При появлении новых слов должен сохраняться алфавитный порядок слов в файле.


# Задание 6

15 баллов

А давайте поддержим передачу в add нескольких файлов

Нет, это не про то, чтобы написать цикл и получить 15 баллов.

Надо собрать всю информацию о добавляемых словах в памяти, а потом единожды все обновить.

То есть сколько бы файлов мы ни указали, каждый "буквенный" файл мы должны обновить только 1 раз.

И зарегистрировать файлы тоже хотелось бы оптимальным образом.


# Задание 7 

15 баллов

Усложним варианты текста.

У нас могут быть знаки препинания. Обычно они цепляются справа: `тот, который`.

Но у нас тексты набраны вручную. Может проскочить `тот ,который`.
Или даже `тот,который`. И их тоже хочется правильно обработать.

Бывают круглые, квадратные, фигурные и угловые скобки. Вот эти могут и слева налипнуть.

Могут быть кавычки разных форм.

От них всех хочется избавиться.

Если в конце слова латиницей стоит апостроф с `s` - отрезаем вместе с `s`.

Если встречается '-' между слов, вплотную примыкая к обоим - считаем одним словом.
(`abc-cde`). Если примыкает справа к левому, а от правого отстоит на 1 пробел - тоже (`abc- cde`).
Если больше - считаем разными словами и отрезаем - от левого. `abc -cde` аналогично.
А вот `abc - cde` считаем разными словами.


# Задание 8
 
10 баллов

Реализуем базовую версию подкоманды `info`.

Выведем данные о количестве файлов, общем количестве обнаруженных слов, а также табличку, сообщающую для
каждой буквы, в скольки документах обнаружены слова, начинающиеся на нее.

